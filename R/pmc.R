#pmc.R


#' Performs a phylogenetic monte carlo between modelA and modelB
#'
#' Simulates data under each model and returns the distribution of 
#' likelihood ratio, L(B)/L(A), under for both simulated datasets.
#' @param tree A phylogenetic tree.  Can be phylo (ape) or ouch tree
#' @param data The data matrix
#' @param modelA a model from the list, or a custom model, see details
#' @param modelB any other model from the list, or custom model, see details
#' @param optionsA a named list of arguments for fitting model A
#' @param optionsB a named list of arguments for fitting model B
#' @param nboot number of bootstrap replicates to use
#' @param ... additional arguments
#' @return 
#' list with the nboot likelihood ratios obtained from fitting both models
#' to data simulated by model A, and the nboot likelihood ratios obtained
#' by fitting both models to simulations from model B, and the likelihood 
#' ratio between the original MLE estimated models from the data.  
#' return has object class pmc. 
#' @details Possible models are all models from fitContinuous, ouch's hansen model
#' @examples
#' require(geiger) # just for the sample data
#' data(geospiza)
#' attach(geospiza)
#' out <- pmc(geospiza.tree, geospiza.data[1], "BM", "lambda", nboot=2)
#' ## FIXME add examples that require conversion of data formats
#' @import snowfall 
#' @import reshape
#' @export
pmc <- function(tree, data, 
                modelA = c("BM", "OU", "lambda", "kappa", "delta", "EB",
                           "white", "trend", "hansen"), 
                modelB = c("BM", "OU", "lambda", "kappa", "delta", "EB",
                           "white", "trend", "hansen"), 
                optionsA=list(), optionsB=list(), nboot=20, ...){

  A <- pmc_fit(tree, data, modelA, optionsA)
  B <- pmc_fit(tree, data, modelB, optionsB)
  lr_orig <- -2*(loglik(A) - loglik(B)) 

  reps <- sfLapply(1:nboot, function(i){
    ## Do the A sims
    simA <- simulate(A)
    if (is(A, "ouchtree"))
      simA <- simA$rep.1
    AfitA <- update(A, data=simA)
    BfitA <- update(B, data=simA)
    lrA <- -2*(loglik(AfitA) - loglik(BfitA)) 

    ## Do the B sims
    simB <- simulate(B)
    if (is(B, "ouchtree"))
      simB <- simB$rep.1
    AfitB <- update(A, data=simB)
    BfitB <- update(B, data=simB)
    lrB <- -2*(loglik(AfitB) - loglik(BfitB))
    list(AA=as.list(c(lr=loglik(AfitA), getParameters(AfitA))), 
         BA=as.list(c(lr=loglik(BfitA), getParameters(BfitA))),
         AB=as.list(c(lr=loglik(AfitB), getParameters(AfitB))), 
         BB=as.list(c(lr=loglik(BfitB), getParameters(BfitB))))
  })
  ## some reformating, for convenience 
  dat <- melt(reps)
  names(dat) <- c("value", "parameter", "comparison", "rep")
  null = -2*(subset(dat, parameter=="lr" & comparison=="AA")$value -
             subset(dat, parameter=="lr" & comparison=="BA")$value)
  test = -2*(subset(dat, parameter=="lr" & comparison=="AB")$value - 
             subset(dat, parameter=="lr" & comparison=="BB")$value)
  output <- list(lr=lr_orig, null=null, test=test, par_dists=dat, 
                 A=A, B=B, call=match.call()) 
  class(output) <- "pmc"
  output
}

#' plot the distributions
#' @param x a pmc object
#' @param ... Additional arguments: 
#'  A= a name for the first model in the pmc pairwise comparison
#'  B= a name for the second model in the pairwise comparison
#' @import ggplot2
#' @method plot pmc
#' @S3method plot pmc
plot.pmc <- function(x, ...){
  if(is.null(A)) 
    A <- "null"
  if(is.null(B)) 
    B <- "test"
  df <- data.frame(x$null, x$test)
  colnames(df) <- c(A, B)
  dat <- melt(df)
  # FIXME strange that ggplot wants 'value' and 'variable' to be unquoted!
  # Makes these appear to be undefined values & creates a warning in check  
  ggplot(dat) + geom_density(aes(value, fill=variable), alpha=.7) +
       geom_vline(x=x$lr, lwd=1, lty=2)
}

#' plot the parameter distributions
#' @param object a pmc object fit
#' @return a ggplot2 plot object
#' @export
plot_pars <- function(object){
  ggplot(object$par_dists) + geom_boxplot(aes(comparison, value)) + facet_wrap(~parameter, scales="free_y") 
}


#' Fit any model used in PMC 
#' @param tree a phylogenetic tree. can be ouch or ape format
#' @param data trait data in ape or ouch format
#' @param model the name of the model to fit, see details for a list of 
#' currently supported types
#' @param options whatever additional options would be provided 
#' to the model fit, see details
#' @return a pmc_model object, anything that has methods "simulate", 
#' "update", getParameters, and getLikelihood
#' @details options should include all parameters required by the fit method
#' Currently methods avialable are fitContinuous (see geiger package) and 
#' hansen (see the ouch package).  
#' @examples 
#' ## a geiger example
#' require(geiger) # just to load the data
#' data(geospiza)
#' attach(geospiza)
#' lambdaFit<-pmc_fit(geospiza.tree, geospiza.data, model="lambda") 
#' ## Or a single trait at a time: 
#' lambdaFit<-pmc_fit(geospiza.tree, geospiza.data[1], model="lambda") 
#' ## an ouch example
#' require(ouch) # just for the data, 
#' data(bimac)
#' tree <- with(bimac,ouchtree(node,ancestor,time/max(time),species))
#' ou.3 <- pmc_fit(data=log(bimac['size']),tree, model="hansen", 
#'                 list(regimes=bimac['OU.3'],sqrt.alpha=1,sigma=1))
#' @import geiger 
#' @import ouch
#' @export
pmc_fit <- function(tree, data, model, options=list()){
  # Figure out if we need ape/geiger based formats or ouch formats
  fitContinuous_types <- c("BM", "OU", "lambda", "kappa", 
                           "delta", "EB", "white", "trend")
  if(model %in% fitContinuous_types){
    type <- "fitContinuous"  
  } else if(model %in% c("brown", "hansen")){
    type <- "hansen"
  } else {
    stop(paste("Model", model, "not recognized"))
  }
  ## Run a fitContinuous fit ##
  if(type == "fitContinuous"){
    # first, check data formats
    if(is(tree, "ouchtree")){
      # assumes data is same order as nodelabels
      names(data) <- tree@nodelabels
      data <- data[data!=NA]
      tree <- convert(tree)
    }
    args <- c(list(tree=tree, data=data, model=model), options) 
    object <- do.call(fitContinuous_object, args) 
  } else if(type == "hansen"){
    ## Fit an ouch object (hansen) 
    if(is(tree, "phylo")){
      tmp <- format_dat(tree, traits)
      tree <- tmp$tree
      data <- tmp$data
    }
    args <- c(list(data=data, tree=tree), options) 
   if(model == "hansen")
       object <- do.call(hansen, args)
   else if(model == "brown")
       object <- do.call(brown, args)
  } else {
    stop("Error: format not recognized.")
  }
  object
}
